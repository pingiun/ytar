use std::{
    ffi::OsStr,
    fmt,
    fs::{self, File},
    io,
    iter::FusedIterator,
    ops::Range,
    os::unix::prelude::OsStrExt,
    path::Path,
    str::from_utf8_unchecked,
};

use ytar::{TarReader, TypeFlag};

/// An iterator over the escaped version of a byte.
///
/// This `struct` is created by the [`escape_default`] function. See its
/// documentation for more.
#[must_use = "iterators are lazy and do nothing unless consumed"]
#[derive(Clone)]
pub struct EscapeDefault {
    range: Range<u8>,
    data: [u8; 4],
}

/// Returns an iterator that produces an escaped version of a `u8`.
///
/// The default is chosen with a bias toward producing literals that are
/// legal in a variety of languages, including C++11 and similar C-family
/// languages. The exact rules are:
///
/// * Tab is escaped as `\t`.
/// * Carriage return is escaped as `\r`.
/// * Line feed is escaped as `\n`.
/// * Single quote is escaped as `\'`.
/// * Double quote is escaped as `\"`.
/// * Backslash is escaped as `\\`.
/// * Any character in the 'printable ASCII' range `0x20` .. `0x7e`
///   inclusive is not escaped.
/// * Any other chars are given hex escapes of the form '\xNN'.
/// * Unicode escapes are never generated by this function.
///
/// # Examples
///
/// ```
/// use std::ascii;
///
/// let escaped = ascii::escape_default(b'0').next().unwrap();
/// assert_eq!(b'0', escaped);
///
/// let mut escaped = ascii::escape_default(b'\t');
///
/// assert_eq!(b'\\', escaped.next().unwrap());
/// assert_eq!(b't', escaped.next().unwrap());
///
/// let mut escaped = ascii::escape_default(b'\r');
///
/// assert_eq!(b'\\', escaped.next().unwrap());
/// assert_eq!(b'r', escaped.next().unwrap());
///
/// let mut escaped = ascii::escape_default(b'\n');
///
/// assert_eq!(b'\\', escaped.next().unwrap());
/// assert_eq!(b'n', escaped.next().unwrap());
///
/// let mut escaped = ascii::escape_default(b'\'');
///
/// assert_eq!(b'\\', escaped.next().unwrap());
/// assert_eq!(b'\'', escaped.next().unwrap());
///
/// let mut escaped = ascii::escape_default(b'"');
///
/// assert_eq!(b'\\', escaped.next().unwrap());
/// assert_eq!(b'"', escaped.next().unwrap());
///
/// let mut escaped = ascii::escape_default(b'\\');
///
/// assert_eq!(b'\\', escaped.next().unwrap());
/// assert_eq!(b'\\', escaped.next().unwrap());
///
/// let mut escaped = ascii::escape_default(b'\x9d');
///
/// assert_eq!(b'\\', escaped.next().unwrap());
/// assert_eq!(b'x', escaped.next().unwrap());
/// assert_eq!(b'9', escaped.next().unwrap());
/// assert_eq!(b'd', escaped.next().unwrap());
/// ```
pub fn escape_default(c: u8) -> EscapeDefault {
    let (data, len) = match c {
        b'\t' => ([b'\t', 0, 0, 0], 1),
        b'\r' => ([b'\\', b'r', 0, 0], 2),
        b'\n' => ([b'\n', 0, 0, 0], 1),
        b'\\' => ([b'\\', 0, 0, 0], 1),
        b'\'' => ([b'\'', 0, 0, 0], 1),
        b'"' => ([b'"', 0, 0, 0], 1),
        b'\x20'..=b'\x7e' => ([c, 0, 0, 0], 1),
        _ => {
            let hex_digits: &[u8; 16] = b"0123456789abcdef";
            (
                [
                    b'\\',
                    b'x',
                    hex_digits[(c >> 4) as usize],
                    hex_digits[(c & 0xf) as usize],
                ],
                4,
            )
        }
    };

    return EscapeDefault {
        range: 0..len,
        data,
    };
}

impl Iterator for EscapeDefault {
    type Item = u8;

    #[inline]
    fn next(&mut self) -> Option<u8> {
        self.range.next().map(|i| self.data[i as usize])
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.range.size_hint()
    }
    fn last(mut self) -> Option<u8> {
        self.next_back()
    }
}
impl DoubleEndedIterator for EscapeDefault {
    fn next_back(&mut self) -> Option<u8> {
        self.range.next_back().map(|i| self.data[i as usize])
    }
}
impl ExactSizeIterator for EscapeDefault {}
impl FusedIterator for EscapeDefault {}

impl fmt::Display for EscapeDefault {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // SAFETY: ok because `escape_default` created only valid utf-8 data
        f.write_str(unsafe {
            from_utf8_unchecked(&self.data[(self.range.start as usize)..(self.range.end as usize)])
        })
    }
}

impl fmt::Debug for EscapeDefault {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EscapeDefault").finish_non_exhaustive()
    }
}

pub fn show_buf<B: AsRef<[u8]>>(buf: B) -> String {
    String::from_utf8(
        buf.as_ref()
            .iter()
            .flat_map(|b| escape_default(*b))
            .collect(),
    )
    .unwrap()
}

fn unpack(file: File) -> io::Result<()> {
    let mut treader = TarReader::new(file);
    while let Some(header) = treader.next()? {
        if !header.is_posix() {
            eprintln!("only posix archives are supported");
            continue;
        }
        if header.path().windows(2).any(|w| w == b"..") {
            eprintln!("paths containing .. are not supported");
            continue;
        }
        let path_cow = header.path();
        let path = Path::new(OsStr::from_bytes(&path_cow));
        match header.typeflag() {
            TypeFlag::Regular => {
                println!("{}", show_buf(&header.path()));
                let mut write = File::create(path)?;
                io::copy(&mut treader, &mut write)?;
            }
            TypeFlag::Directory => {
                fs::create_dir_all(path)?;
            }
            t => {
                eprintln!(
                    "only regular files and directories are supported, not {:?}",
                    t
                );
                continue;
            }
        }
    }
    Ok(())
}

fn pack<P: AsRef<Path>>(folder: P) -> io::Result<()> {
    todo!()
}

fn main() {
    let filename = "./long.tar";
    let file = File::open(filename).expect("file doesn't exist");
    unpack(file).expect("cannot unpack");
}
